#' Create transition layer from polygon shapefile
#'
#' Create transition layer for [interpolate_path] from polygon shapefile.
#'
#' @param in_file A sf, SpatialPolygonsDataFrame object, or a character string
#'   with file path to polygon shapefile (with extension of *.shp). Default
#'   arguments assume the polygon represents a water body. If the polygon
#'   represents a land mass, then `invert` will need to be set to
#'   `TRUE`.
#'
#' @param output character, name of output file with .tif extension
#'
#' @param output_dir character, directory where output file will be written. If
#'   NULL (default), then files will be written to temporary directory that
#'   will be deleted after R session is closed (see [tempdir][tempfile]).
#'
#' @param res two element vector that specifies the x and y dimension of output
#'   raster cells.  Units of res are same as input shapefile.
#'
#' @param all_touched logical. If TRUE (default) then any pixel touched by
#'   polygon 'in_file' will be coded as water in the output. Alternatively,
#'   pixel must be at least 50% covered by polygon to be coded as water.
#'
#' @param invert logical. Passes into [gdal_rasterize][gdalUtilities::gdal_rasterize]. If
#'   true, it will return the inverse of the raster object it would normally
#'   return. This can be useful if the polygon passed represents a landmass
#'   rather than a body of water, such as the ones generated by GADM.
#'
#' @details `make_transition` uses
#'   [gdal_rasterize][gdalUtilities::gdal_rasterize] to convert a polygon shapefile
#'   into a raster layer and geo-corrected transition layer
#'   [interpolate_path].  Raster cell values on land = 0 and
#'   water = 1. Function also writes a geotiff file (*.tif) of the
#'   input shapefile to the ouput directory. Both raster layer and
#'   geotif output have the same extents and geographic projection as
#'   input shapefile.  Function requires that gdal is working on
#'   computer.  To determine if gdal is installed on your computer,
#'   see [gdal_rasterize][gdalUtilities::gdal_rasterize].
#'
#' @details Returned objects will be projected in longlat WGS84
#'   (i.e., CRS("+init=epsg:4326"). If the input object is not recognizable in
#'   epsg:4326 then transformation will be attempted and a
#'   warning will tell the user this was done.  Input shapefile must
#'   include an optional *.prj file that specifies the geographic projection.
#'
#' @details Output transition layer is corrected for projection
#'   distortions using `gdistance::geoCorrection`.  Adjacent
#'   cells are connected by 16 directions and transition function
#'   returns 0 (land) for movements between land and water and 1 for
#'   all over-water movements.
#'
#' @return A list with two elements:
#' \itemize{
#'    \item{`transition:`}{ a geo-corrected transition raster layer where land = 0
#'       and water=1 (see `gdistance`)}
#'    \item{`rast:`}{ rasterized input layer of class `raster`}}
#'   Additionally, rasterized version of input shapefile (*.tif extension) is
#'   written to computer at `output_dir`
#' 
#'
#' @author Todd Hayden, Tom Binder, Chris Holbrook
#'
#' @examples
#' \dontrun{
#' 
#' #Example 1 - read from sf polygon
#' # use example polygon for Great lakes
#'
#' library(sf) #for loading great_lakes_polygon
#' library(raster) # for plotting rasters
#'
#' # Get polygon of the Great Lakes
#' data(great_lakes_polygon) #glatos example data; an sf polygons object
#'
#' # Make transition layer
#' tst <- make_transition(great_lakes_polygon, res = c(0.1, 0.1))
#'
#' # plot raster layer
#' # notice land = 1, water = 0
#' plot(tst$rast)
#'
#' #compare to polygon
#' plot(sf::st_geometry(great_lakes_polygon), add = TRUE)
#' 
#' 
#' #Example 2 - read from SpatialPolygonsDataFrame
#' # use example polygon for Great lakes
#'
#' library(sp) #for loading greatLakesPoly
#' library(raster) # for plotting rasters
#'
#' #get polygon of the Great Lakes
#' data(greatLakesPoly) #glatos example data; a SpatialPolygonsDataFrame
#'
#' # make_transition layer
#' tst <- make_transition(greatLakesPoly, res = c(0.1, 0.1))
#'
#' # plot raster layer
#' # notice land = 1, water = 0
#' plot(tst$rast)
#'
#' #compare to polygon
#' plot(greatLakesPoly, add = TRUE)
#'
#' # increase resolution and repeat if needed
#'
#' #------------------------------------------
#' #Example 3 - read from ESRI Shapefile
#' # path to polygon shapefile
#' poly <- system.file("extdata", "shoreline.zip", package = "glatos")
#' poly <- unzip(poly, exdir = tempdir())
#'
#' # make_transition layer
#' tst <- make_transition(poly[grepl("*.shp", poly)], res = c(0.1, 0.1))
#'
#' # plot raster layer
#' # notice land = 0, water = 1
#' raster::plot(tst$rast)
#'
#' # plot transition layer
#' raster::plot(raster::raster(tst$transition))
#'
#' # increase resolution- this may take some time...
#' tst1 <- make_transition(poly[grepl("*.shp", poly)], res = c(0.01, 0.01))
#'
#' # plot raster layer
#' raster::plot(tst1$rast)
#'
#' # plot transition layer
#' raster::plot(raster::raster(tst1$transition))
#' }
#'
#'
#'
#' @name make_transition-deprecated
#' @seealso \code{\link{glatos-deprecated}}
#' @keywords internal
NULL
#' @rdname glatos-deprecated
#' @section \code{make_transition}:
#' For \code{make_transition}, use \code{\link{make_transition3}}.

#'
#'
#'
#' @export


make_transition <- function(in_file, 
                            output = "out.tif",
                            output_dir = NULL, 
                            res = c(0.1, 0.1),
                            invert = FALSE,
                            all_touched = TRUE){
  
  # Function will be removed in next version
  .Deprecated("make_transition3", msg = "This function is deprecated and will be removed in the next version")
  
  #Check if in_file is file, directory, sf, or SpatialPolygonsDataFrame
  if(inherits(in_file, "character")){

    #check if in_file exists
    if(!file.exists(in_file)) stop("Input file or folder '", 
                                   in_file, "' not found.")

    #check if file or directory and set layer name accordingly
    if(grepl("\\.shp$", in_file)){

      in_dir <- dirname(in_file)

      if(!file.exists(in_dir)) stop("'in_file' directory '", in_dir, 
                                    "' not found.")

      #get layer name from file name
      in_layer <- basename(tools::file_path_sans_ext(basename(in_file)))

    } else {

      in_dir <- in_file

      #use layer name as file name
      in_layer <- sf::st_layers(in_dir)$name

    }

    #read shape file
    in_shp <- sf::read_sf(in_dir, layer = in_layer)

  } else if (inherits(in_file, "SpatialPolygonsDataFrame")) {

    #convert to sf
    in_shp <- sf::st_as_sf(in_file)

    #use incoming object name as layer
    in_layer <- deparse(substitute(in_file))

  } else if (inherits(in_file, "sf")){
   
    in_shp <- in_file
    
    #use incoming object name as layer
    in_layer <- deparse(substitute(in_file))    
    
  } else {

    stop("'in_file' must be either an object of class 'sf', ",
         "'SpatialPolygonsDataFrame', or\n",
         " path to an ESRI Shapefile.")

  }

  #check if POLYGON object
  if (!all(sf::st_geometry_type(in_shp) == "POLYGON")){
    stop(paste0("Input can only contain polygon data."))
  }

  #check projection and change if needed
  default_crs <- 4326
  
  crs_in <- sf::st_crs(in_shp)$epsg
  
  if(is.na(crs_in) | (crs_in  != default_crs)){
    warning("CRS of input was not EPSG:4326, so conversion was attempted.",
            call. = FALSE)
    in_shp <- sf::st_transform(in_shp, default_crs)
  }

  #write to temp dir and call gdal_rasterize
  temp_dir <- path.expand(file.path(tempdir(), in_layer))

  sf::st_write(in_shp, dsn = temp_dir, 
               layer = in_layer,
               driver = "ESRI Shapefile",
               append = FALSE,
               quiet = TRUE)

  if(is.null(output_dir)) output_dir <- temp_dir

  burned <- gdalUtilities::gdal_rasterize(temp_dir,
                      dst_filename = path.expand(file.path(output_dir, output)),
                      burn = 1,
                      tr = res,
                      i = invert,
                      at = all_touched)
      
  burned <- raster::raster(burned, layer = 1)
  

  tran <- function(x){if(x[1] * x[2] == 0){return(0)} else {return(1)}}
  tr1 <- gdistance::transition(burned, transitionFunction = tran, 
                               directions = 16)
  tr1 <- gdistance::geoCorrection(tr1, type="c")
  out <- list(transition = tr1, rast = burned)
  return(out)
}
